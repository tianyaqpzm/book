

# 动态规划



![20210117171307407](REAMME/20210117171307407.png)

[参考](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85)




# 关键点
1. 状态定义
2. 状态转移方程
3. 状态枚举

70.爬楼梯
一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？

### 思路
由于第 n 级台阶一定是从 n - 1 级台阶或者 n - 2 级台阶来的，因此到第 n 级台阶的数目就是 到第 n - 1 级台阶的数目加上到第 n - 1 级台阶的数目。

$$
  dp[i]: 第i级台阶爬楼梯的方法 \\
  dp[i]=\left
  \{
  \begin{aligned}
  dp[i-1] + dp[i-2] && i > 2 \\
  0 & & i = 0,1,2 \\
  \end{aligned}
  \right.
$$



1.   零钱兑换
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

$$
   f(i, j) 表示用 coins 的前 i 项找 j 元需要的最少硬币数。那么答案就是 f(len(coins) - 1, amount)。 \\
   
   而这道题的核心在于 coins[i] 选择与否其实没有那么重要，重要的其实是选择的 coins 一共有多少钱。 
因此我们可以定义 :\\
f(i, j) 表示选择了 coins 的前 i 项（怎么选的不关心），且组成 j 元需要的最少硬币数。 \\
dp[i][j]：使用coins[0...i]这么多硬币的情况下，组成目标金额为j时的最少硬币数量\\
  dp[i][j]=\left
  \{
  \begin{aligned}
   min( dp[i-1][j], dp[i][j-coin[i]] +1) && j >= coin[i] \\
                         amount+1        && j < coin[i] \\
  \end{aligned}
  \right.
$$

这个动态转移方程转换成了01背包问题
不选当前的coins[i] 用i-1个硬币组成金额为jj最少硬币数量：dp[i-1][j]
选当前的coins[i] 用i个硬币组成金额为j最少硬币数量：dp[i][j-coins[i]]+1

一维优化
$$
 dp[j]：凑足总额为j所需钱币的最少个数为dp[j]. \\
 
 dp[j]= \left
  \{
  \begin{aligned}
 min( p[j - coins[i]] + 1,dp[j]) && j >= coin[i] \\
                         none        && j < coin[i] \\
  \end{aligned}
  \right.
 
$$


> 由组合原理，coins 的所有选择状态是 $2^n$。状态总数就是 i 和 j 的取值的笛卡尔积，也就是 2^len(coins) * (amount + 1)。
> 
> 减 1 是因为存在 0 元的情况。


## 关键点：
倒叙遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！


举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历
dp[1] = dp[1 - weight[0]] + value[0] = 15
dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒叙遍历，就可以保证物品只放入一次呢？
倒叙就是先算dp[2]
dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）
dp[1] = dp[1 - weight[0]] + value[0] = 15



一维数组 两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。
 dp[j]：凑足总额为j所需钱币的最少个数为dp[j]. 
> 正序 可以（已验证）， 倒序不可以（待验证）
> 
